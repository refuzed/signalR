/**
 * @license jCanvas v13.06.21
 * Copyright 2013 Caleb Evans
 * Released under the MIT license
 */(function (e, t, n, r, i, s, o, u, a) { function C(e) { var t = this; l(t, e); return t } function k(e) { e ? l(C.prototype, e) : k.prefs = C.prototype = l({}, f); return this } function L(e) { return h(e) === "string" } function A(e) { return e && e.getContext ? e.getContext("2d") : u } function O(e, t) { e.save(); t.savedTransforms.push(_(t.transforms)) } function M(e, t) { if (t.savedTransforms.length === 0) t.transforms = _(x); else { e.restore(); t.transforms = t.savedTransforms.pop() } } function _(e) { e = l({}, e); e.masks = e.masks.slice(0); return e } function D(e, t, n) { p(n.fillStyle) ? t.fillStyle = n.fillStyle.call(e, n) : t.fillStyle = n.fillStyle; p(n.strokeStyle) ? t.strokeStyle = n.strokeStyle.call(e, n) : t.strokeStyle = n.strokeStyle; t.lineWidth = n.strokeWidth; if (n.rounded) t.lineCap = t.lineJoin = "round"; else { t.lineCap = n.strokeCap; t.lineJoin = n.strokeJoin; t.miterLimit = n.miterLimit } t.shadowOffsetX = n.shadowX; t.shadowOffsetY = n.shadowY; t.shadowBlur = n.shadowBlur; t.shadowColor = n.shadowColor; t.globalAlpha = n.opacity; t.globalCompositeOperation = n.compositing; n.imageSmoothing && (t.webkitImageSmoothingEnabled = t.mozImageSmoothingEnabled = n.imageSmoothing) } function P(e, t, n) { if (n.mask) { n.autosave && O(e, t); e.clip(); t.transforms.masks.push(n._args) } } function H(e, t) { t._transformed && e.restore() } function B(e, t, n) { var r; n.closed && t.closePath(); if (n.shadowStroke && n.strokeWidth !== 0) { t.stroke(); t.fill(); t.shadowColor = "transparent"; t.shadowBlur = 0; t.stroke() } else { t.fill(); n.fillStyle !== "transparent" && (t.shadowColor = "transparent"); n.strokeWidth !== 0 && t.stroke() } n.closed || t.closePath(); H(t, n); if (n.mask) { r = R(e); P(t, r, n) } } function j(e, t, n) { t._toRad = t.inDegrees ? v / 180 : 1; e.translate(t.x, t.y); e.rotate(t.rotate * t._toRad); e.translate(-t.x, -t.y); n.rotate += t.rotate * t._toRad } function F(e, t, n) { t.scale !== 1 && (t.scaleX = t.scaleY = t.scale); e.translate(t.x, t.y); e.scale(t.scaleX, t.scaleY); e.translate(-t.x, -t.y); n.scaleX *= t.scaleX; n.scaleY *= t.scaleY } function I(e, t, n) { t.translate && (t.translateX = t.translateY = t.translate); e.translate(t.translateX, t.translateY); n.translateX += t.translateX; n.translateY += t.translateY } function q(e, t, n, r) { t._toRad = t.inDegrees ? v / 180 : 1; t._transformed = s; e.save(); r === a && (r = n); if (!t.fromCenter && !t._centered) { t.x += n / 2; t.y += r / 2; t._centered = s } t.rotate && j(e, t, {}); (t.scale !== 1 || t.scaleX !== 1 || t.scaleY !== 1) && F(e, t, {}); (t.translate || t.translateX || t.translateY) && I(e, t, {}) } function R(t) { var n; if (S._canvas === t && S._data) n = S._data; else { n = e.data(t, "jCanvas"); if (!n) { n = { canvas: t, layers: [], layer: { names: {}, groups: {} }, intersecting: [], drag: {}, event: { type: u, x: u, y: u }, events: {}, transforms: _(x), savedTransforms: [], animating: o, animated: u, pixelRatio: 1, scaled: !1 }; e.data(t, "jCanvas", n) } S._canvas = t; S._data = n } return n } function U(e, t, n) { var r; for (r in k.events) k.events.hasOwnProperty(r) && z(e, t, n, r) } function z(e, t, n, r) { if (n[r]) { r = tt(r); k.events[r](e, t); n._event = s } } function W(e, t, n) { var r, i, o; if (n.draggable || n.dragGroupWithLayer || n.cursor) { r = ["mousedown", "mousemove", "mouseup"]; for (o = 0; o < r.length; o += 1) { i = tt(r[o]); k.events[i](e, t) } if (!t.events.mouseoutdrag) { e.bind("mouseout.jCanvas", function () { var n = t.drag.layer; if (n) { t.drag = {}; n.dragcancel && n.dragcancel.call(e[0], n); e.drawLayers() } }); t.events.mouseoutdrag = s } n._event = s } } function X(e, t, n, r) { var i = t.layer.names; r ? r.name !== a && L(n.name) && n.group !== r.group && delete i[n.name] : r = n; L(r.name) && (i[r.name] = n) } function V(e, t, n, r) { var i = t.layer.groups, s, o, u; if (!r) r = n; else if (r.group !== a && L(n.group) && n.group !== r.group) { s = i[n.group]; if (s) { for (u = 0; u < s.length; u += 1) if (s[u] === n) { o = u; s.splice(u, 1); break } s.length === 0 && delete i[n.group] } } if (L(r.group)) { s = i[r.group]; if (!s) { s = i[r.group] = []; s.name = r.group } o === a && (o = s.length); s.splice(o, 0, n) } } function $(e, t, n, r) { if (n && n.visible && n._method) { r ? n._next = r : n._next = u; n._method.call(e, n) } } function J(t, n, r, i) { var o, u, f = r, l; n._args = r; n.canvas = t; if (n.draggable) { n.layer = s; n.draggable = s } i ? n._method = i : n.method ? n._method = e.fn[n.method] : n.type ? n._method = e.fn[E[n.type]] : n._method = function () { }; if (n.layer && !n._layer) { o = e(t); u = o.getLayers(); l = R(t); f = new C(n); X(o, l, f); V(o, l, f); U(o, l, f); W(o, l, f); n._event = f._event; f.layer = s; f._layer = s; f.index === a && (f.index = u.length); u.splice(f.index, 0, f) } return f } function K(e) { var t; for (t = 0; t < T.length; t += 1) e[T[t]] = e["_" + T[t]] } function Q(e, t) { var n; for (n = 0; n < T.length; n += 1) { e["_" + T[n]] = e[T[n]]; N[T[n]] = 1; t && delete e[T[n]] } } function G(e, t, n) { var r; for (r in n) n.hasOwnProperty(r) && p(n[r]) && (n[r] = n[r].call(e, t, r)); return n } function Y(n) { var r, s, o = [], u = 1; if (n.match(/^#?\w+$/i)) { n === "transparent" && (n = "rgba(0,0,0,0)"); s = t.head; r = s.style.color; s.style.color = n; n = e.css(s, "color"); s.style.color = r } if (n.match(/^rgb/i)) { o = n.match(/\d+/gi); n.match(/%/gi) && (u = 2.55); o[0] *= u; o[1] *= u; o[2] *= u; o[3] !== a ? o[3] = i(o[3]) : o[3] = 1 } return o } function Z(e) { var t = 3, n; if (h(e.start) !== "array") { e.start = Y(e.start); e.end = Y(e.end) } e.now = []; if (e.start[3] !== 1 || e.end[3] !== 1) t = 4; for (n = 0; n < t; n += 1) { e.now[n] = e.start[n] + (e.end[n] - e.start[n]) * e.pos; n < 3 && (e.now[n] = d(e.now[n])) } if (e.start[3] !== 1 || e.end[3] !== 1) e.now = "rgba(" + e.now.join(",") + ")"; else { e.now.slice(0, 3); e.now = "rgb(" + e.now.join(",") + ")" } e.elem.nodeName ? e.elem.style[e.prop] = e.now : e.elem[e.prop] = e.now } function et(t) { var n; for (n = 0; n < t.length; n += 1) e.fx.step[t[n]] = Z } function tt(e) { "ontouchstart" in window && b[e] && (e = b[e]); return e } function nt(e) { w[e] && (e = w[e]); return e } function rt(e) { k.events[e] = function (t, n) { e = tt(e); var r = e === "mouseover" || e === "mouseout" ? "mousemove" : e, i = n.event; if (!n.events[r]) { t.bind(r + ".jCanvas", function (e) { i.x = e.offsetX; i.y = e.offsetY; i.type = r; i.event = e; t.drawLayers({ resetFire: s }); e.preventDefault() }); n.events[r] = s } } } function it(e, t, n) { var r, i, o, a, f, l, c, h; r = n._args; if (r._event) { i = R(e); o = i.event; if (o.x !== u && o.y !== u) { l = o.x * i.pixelRatio; c = o.y * i.pixelRatio; a = t.isPointInPath(l, c) || t.isPointInStroke && t.isPointInStroke(l, c) } f = i.transforms; r.eventX = r.mouseX = o.x; r.eventY = r.mouseY = o.y; r.event = o.event; h = i.transforms.rotate; l = r.eventX; c = r.eventY; if (h !== 0) { r._eventX = l * g(-h) - c * m(-h); r._eventY = c * g(-h) + l * m(-h) } else { r._eventX = l; r._eventY = c } r._eventX /= f.scaleX; r._eventY /= f.scaleY; !a && r._hovered && !r._fired && (r._mousedout = s); a && i.intersecting.push(r); r.intersects = a } } function st(e, t) { if (t.font) e.font = t.font; else { isNaN(Number(t.fontSize)) || (t.fontSize += "px"); e.font = t.fontStyle + " " + t.fontSize + " " + t.fontFamily } } function ot(t, n, r, s) { var o, u, a = /\b(\d*\.?\d*)\w\w\b/gi, f, l; if (S.text === r.text && S.font === r.font && S.fontStyle === r.fontStyle && S.fontSize === r.fontSize && S.fontFamily === r.fontFamily && S.maxWidth === r.maxWidth && S.lineHeight === r.lineHeight) { r.width = S.width; r.height = S.height } else { r.width = n.measureText(s[0]).width; for (f = 1; f < s.length; f += 1) { l = n.measureText(s[f]).width; l > r.width && (r.width = l) } o = t.style.fontSize; if (r.font) { u = r.font.match(a); u && (t.style.fontSize = r.font.match(a)[0]) } else t.style.fontSize = r.fontSize; r.height = i(e.css(t, "fontSize")) * s.length * r.lineHeight; t.style.fontSize = o } } function ut(e, t) { var n = t.text, r = t.maxWidth, i = n.split(" "), s, o = [], u = ""; if (e.measureText(n).width < r || i.length === 1) o = [n]; else { for (s = 0; s < i.length; s += 1) { if (e.measureText(u + i[s]).width > r) { u !== "" && o.push(u); u = "" } u += i[s]; s !== i.length - 1 && (u += " ") } o.push(u) } o = o.join("\n").replace(/( (\n))|( $)/gi, "$2").split("\n"); return o } var f, l = e.extend, c = e.inArray, h = e.type, p = e.isFunction, d = r.round, v = r.PI, m = r.sin, g = r.cos, y = e.event.fix, b, w, E, S = {}, x = { rotate: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, masks: [{ intersects: s }] }, T, N; e.fn.jCanvas = k; k.events = {}; f = { align: "center", autosave: s, baseline: "middle", bringToFront: o, ccw: o, closed: o, compositing: "source-over", concavity: 0, cornerRadius: 0, count: 1, cropFromCenter: s, disableDrag: o, disableEvents: o, domain: u, draggable: o, group: u, data: {}, each: u, end: 360, fillStyle: "transparent", font: "", fontStyle: "normal", fontSize: "12pt", fontFamily: "sans-serif", fromCenter: s, fn: u, graph: "y", height: u, imageSmoothing: s, inDegrees: s, lineHeight: 1, layer: o, load: u, mask: o, maxWidth: u, miterLimit: 10, name: u, opacity: 1, projection: 0, r1: u, r2: u, radius: 0, range: u, repeat: "repeat", respectAlign: o, rotate: 0, rounded: o, scale: 1, scaleX: 1, scaleY: 1, shadowBlur: 0, shadowColor: "transparent", shadowStroke: !1, shadowX: 0, shadowY: 0, sHeight: u, sides: 0, source: "", start: 0, strokeCap: "butt", strokeJoin: "miter", strokeStyle: "transparent", strokeWidth: 1, sWidth: u, sx: u, sy: u, text: "", translate: 0, translateX: 0, translateY: 0, type: u, visible: s, width: u, x: 0, y: 0 }; k(); k.extend = function (n) { k.defaults = l(f, n.props); k(); n.name && (e.fn[n.name] = function r(e) { var t = this, i, s, o, u = new C(e); for (s = 0; s < t.length; s += 1) { i = t[s]; o = A(i); if (o) { e = J(i, u, e, r); D(i, o, u); n.fn.call(i, o, u) } } return t }); return e.fn[n.name] }; e.fn.getLayers = function (t) { var n = this[0], r, i, s = []; if (n && n.getContext) { r = R(n).layers; if (p(t)) for (i = 0; i < r.length; i += 1) t.call(n, r[i]) && s.push(r[i]); else s = r } return s }; e.fn.getLayer = function (t) { var n = this.getLayers(), r = h(t), i = R(this[0]), s, o; if (t && t.layer) s = t; else if (r === "number") { t < 0 && (t = n.length + t); s = n[t] } else if (r === "regexp") { for (o = 0; o < n.length; o += 1) if (L(n[o].name) && n[o].name.match(t)) { s = n[o]; break } } else { i = R(this[0]); s = i.layer.names[t] } return s }; e.fn.getLayerGroup = function (t) { var n = h(t), r, i, s, o; if (n === "array") return t; if (n === "regexp") { o = R(this[0]); r = o.groups; for (i in r) if (i.match(t)) { s = r[i]; break } } else { o = R(this[0]); s = o.layer.groups[t] } return s }; e.fn.getLayerIndex = function (t) { var n = this.getLayers(), r = this.getLayer(t); return c(r, n) }; e.fn.setLayer = function (n, r) { var i = this, s, o, u, a; for (o = 0; o < i.length; o += 1) { s = e(i[o]); u = R(i[o]); a = e(i[o]).getLayer(n); if (a) { X(s, u, a, r); V(s, u, a, r); l(a, r); U(s, u, a); W(s, u, a) } } return i }; e.fn.setLayerGroup = function (n, r) { var i = this, s, o, u, a; for (o = 0; o < i.length; o += 1) { s = e(i[o]); u = s.getLayerGroup(n); if (u) for (a = 0; a < u.length; a += 1) s.setLayer(u[a], r) } return i }; e.fn.setLayers = function (n) { var r = this, i, s, o, u; for (s = 0; s < r.length; s += 1) { i = e(r[s]); o = e(r[s]).getLayers(); for (u = 0; u < o.length; u += 1) i.setLayer(o[u], n) } return r }; e.fn.moveLayer = function (n, r) { var i = this, s, o, u, a; for (o = 0; o < i.length; o += 1) { s = e(i[o]); u = s.getLayers(); a = s.getLayer(n); if (a) { a.index = c(a, u); u.splice(a.index, 1); u.splice(r, 0, a); r < 0 && (r = u.length + r); a.index = r } } return i }; e.fn.removeLayer = function (n) { var r = this, i, s, o, a, f; for (s = 0; s < r.length; s += 1) { i = e(r[s]); o = R(r[s]); a = i.getLayers(); f = i.getLayer(n); if (f) { f.index = c(f, a); a.splice(f.index, 1); X(i, o, f, { name: u }); V(i, o, f, { group: u }) } } return r }; e.fn.removeLayerGroup = function (n) { var r = this, i, s, o, f, l, h, p; if (n !== a) for (s = 0; s < r.length; s += 1) { i = e(r[s]); o = R(r[s]); f = i.getLayers(); l = i.getLayerGroup(n); if (l) { for (p = 0; p < l.length; p += 1) { h = l[p]; h.index = c(h, f); f.splice(h.index, 1); X(i, o, h, { name: u }) } delete o.layer.groups[l.name] } } return r }; e.fn.removeLayers = function () { var n = this, r, i, s; for (i = 0; i < n.length; i += 1) { r = e(n[i]); s = R(n[i]); s.layers.length = 0; s.layer.names = {}; s.layer.groups = {} } return n }; e.fn.drawLayer = function at(t) { var n = this, r, i, s, o; for (r = 0; r < n.length; r += 1) { s = e(n[r]); i = A(n[r]); o = s.getLayer(t); at(s, i, o) } return n }; e.fn.drawLayers = function (n) { var r = this, i, a, f, l = n || {}, h, p, d, v, m, g, y, b, w, E, S, T; l.index || (l.index = 0); for (a = 0; a < r.length; a += 1) { i = e(r[a]); f = A(r[a]); if (f) { y = R(r[a]); l.clear !== o && i.clearCanvas(); h = y.layers; for (d = l.index; d < h.length; d += 1) { p = h[d]; p.index = d; l.resetFire && (p._fired = o); p._event = !p.disableEvents; $(i, f, p, d + 1); p._masks = y.transforms.masks.slice(0); if (p._mousedout) { p._mousedout = o; p._fired = s; p._hovered = o; p.mouseout && p.mouseout.call(r[a], p); p.cursor && p._cursor && i.css({ cursor: p._cursor }) } if (p._method === e.fn.drawImage && p.visible) break } v = d; p = {}; for (m = y.intersecting.length - 1; m >= 0; m -= 1) { p = y.intersecting[m]; p._prevMasksIntersect = s; for (g = p._masks.length - 1; g >= 0; g -= 1) if (p && !p._masks[g].intersects) { p._prevMasksIntersect = o; break } if (p._prevMasksIntersect) break } b = y.event; w = b.type; p[w] || (w = nt(w)); T = p[w]; E = y.drag; if (p._event && p._prevMasksIntersect) { if (p.mouseover || p.mouseout || p.cursor) if (!p._hovered && !p._fired) { p._fired = s; p._hovered = s; p.mouseover && p.mouseover.call(r[a], p); if (p.cursor) { p._cursor = i.css("cursor"); i.css({ cursor: p.cursor }) } } if (T && !p._fired) { p._fired = s; b.type = u; T.call(r[a], p) } p.draggable && !p.disableDrag && (w === "mousedown" || w === "touchstart") && (E.layer = p) } if (E.layer) { if (w === "mouseup" || w === "touchend") { if (E.layer.dragstop && E.dragging) { E.layer.dragstop.call(i, E.layer); E.dragging = o } y.drag = {} } if (w === "mousemove" || w === "touchmove") { if (!E.dragging) { E.dragging = s; E.layer.dragstart && E.layer.dragstart.call(i, E.layer); if (E.layer.bringToFront) { h.splice(E.layer.index, 1); E.layer.index = h.push(E.layer) } S = y.layer.groups[E.layer.group]; if (E.layer.group && E.layer.dragGroupWithLayer && S) for (d = 0; d < S.length; d += 1) if (S[d] !== E.layer) { S[d]._startX = S[d].x; S[d]._startY = S[d].y; S[d]._endX = E.layer._eventX; S[d]._endY = E.layer._eventY; if (S[d].bringToFront) { S[d].index = c(S[d], h); h.splice(S[d].index, 1); h.splice(-1, 0, S[d]); S[d].index = h.length - 2 } } E._startX = E.layer._startX = E.layer.x; E._startY = E.layer._startY = E.layer.y; E._endX = E.layer._endX = E.layer._eventX; E._endY = E.layer._endY = E.layer._eventY } E.layer.x = E.layer._eventX - (E._endX - E._startX); E.layer.y = E.layer._eventY - (E._endY - E._startY); E.layer.drag && E.layer.drag.call(i, E.layer); S = y.layer.groups[E.layer.group]; if (E.layer.group && E.layer.dragGroupWithLayer && S) for (d = 0; d < S.length; d += 1) if (S[d] !== E.layer) { S[d].x = E.layer._eventX - (S[d]._endX - S[d]._startX); S[d].y = E.layer._eventY - (S[d]._endY - S[d]._startY) } } } if (v === h.length) { y.intersecting.length = 0; y.transforms.masks.length = 0; y.transforms = _(x); y.savedTransforms.length = 0 } } } return r }; e.fn.addLayer = function (t) { var n = this, r, i, o; o = new C(t); for (r = 0; r < n.length; r += 1) { i = A(n[r]); if (i) { o.layer = s; t = J(n[r], o, t) } } return n }; T = ["width", "height", "opacity", "lineHeight"]; N = {}; e.fn.animateLayer = function () { function g(e, t, n) { return function () { K(n); (!t.animating || t.animated === n) && e.drawLayers(); c[4] && c[4].call(e[0], n); n._animating = o; t.animating = o; t.animated = u } } function y(e, t, n) { return function (r, i) { K(n); if (!n._animating && !t.animating) { n._animating = s; t.animating = s; t.animated = n } (!t.animating || t.animated === n) && e.drawLayers(); c[5] && c[5].call(e[0], r, i, n) } } var n = this, r, i, f, c = [].slice.call(arguments, 0), d, v, m; h(c[0]) === "object" && !c[0].layer && c.unshift(0); if (h(c[2]) === "object") { c.splice(2, 0, c[2].duration || u); c.splice(3, 0, c[3].easing || u); c.splice(4, 0, c[4].complete || u); c.splice(5, 0, c[5].step || u) } else { if (c[2] === a) { c.splice(2, 0, u); c.splice(3, 0, u); c.splice(4, 0, u) } else if (p(c[2])) { c.splice(2, 0, u); c.splice(3, 0, u) } if (c[3] === a) { c[3] = u; c.splice(4, 0, u) } else p(c[3]) && c.splice(3, 0, u) } for (i = 0; i < n.length; i += 1) { r = e(n[i]); f = A(n[i]); if (f) { d = R(n[i]); v = r.getLayer(c[0]); if (v && v._method !== e.fn.draw) { m = l({}, c[1]); m = G(n[i], v, m); Q(m, s); Q(v); v.style = N; e(v).animate(m, { duration: c[2], easing: e.easing[c[3]] ? c[3] : u, complete: g(r, d, v), step: y(r, d, v) }) } } } return n }; e.fn.animateLayerGroup = function (n) { var r = this, i, s, o = [].slice.call(arguments, 0), u, a; for (s = 0; s < r.length; s += 1) { i = e(r[s]); u = i.getLayerGroup(n); for (a = 0; a < u.length; a += 1) i.animateLayer.apply(i, [u[a]].concat(o.slice(1))) } return r }; e.fn.delayLayer = function (n, r) { var i = this, s, o; r = r || 0; for (s = 0; s < i.length; s += 1) { o = e(i[s]).getLayer(n); e(o).delay(r) } return i }; e.fn.delayLayerGroup = function (n, r) { var i = this, s, o, u, a, f; r = r || 0; for (o = 0; o < i.length; o += 1) { s = e(i[o]); u = s.getLayerGroup(n); if (u) for (f = 0; f < u.length; f += 1) { a = u[f]; a && e(a).delay(r) } } return i }; e.fn.stopLayer = function (n, r) { var i = this, s, o; for (s = 0; s < i.length; s += 1) { o = e(i[s]).getLayer(n); o && e(o).stop(r) } return i }; e.fn.stopLayerGroup = function (n, r) { var i = this, s, o, u, a, f; for (o = 0; o < i.length; o += 1) { s = e(i[o]); u = s.getLayerGroup(n); if (u) for (f = 0; f < u.length; f += 1) { a = u[f]; a && e(a).stop(r) } } return i }; et(["color", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "fillStyle", "outlineColor", "strokeStyle", "shadowColor"]); b = { mousedown: "touchstart", mouseup: "touchend", mousemove: "touchmove" }; w = { touchstart: "mousedown", touchend: "mouseup", touchmove: "mousemove" }; rt("click"); rt("dblclick"); rt("mousedown"); rt("mouseup"); rt("mousemove"); rt("mouseover"); rt("mouseout"); rt("touchstart"); rt("touchmove"); rt("touchend"); e.event.fix = function (t) { var n, r, i; t = y.call(e.event, t); r = t.originalEvent; if (r) { i = r.changedTouches; if (t.pageX !== a && t.offsetX === a) { n = e(t.target).offset(); if (n) { t.offsetX = t.pageX - n.left; t.offsetY = t.pageY - n.top } } else if (i) { n = e(r.target).offset(); if (n) { t.offsetX = i[0].pageX - n.left; t.offsetY = i[0].pageY - n.top } } } return t }; E = { arc: "drawArc", bezier: "drawBezier", circle: "drawArc", ellipse: "drawEllipse", "function": "draw", image: "drawImage", line: "drawLine", polygon: "drawPolygon", quadratic: "drawQuadratic", rectangle: "drawRect", text: "drawText", vector: "drawVector" }; e.fn.draw = function ft(t) { var n = this, r, i, s, o; o = new C(t); for (i = 0; i < n.length; i += 1) { r = e(n[i]); s = A(n[i]); if (s) { t = J(n[i], o, t, ft); o.visible && (o.fn ? o.fn.call(n[i], s, o) : o._method !== ft && o._method.call(r, t)) } } return n }; e.fn.clearCanvas = function (t) { var n = this, r, i, s = new C(t); for (r = 0; r < n.length; r += 1) { i = A(n[r]); if (i) if (!s.x || !s.y || !s.width || !s.height) { i.save(); i.setTransform(1, 0, 0, 1, 0, 0); i.clearRect(0, 0, n[r].width, n[r].height); i.restore() } else { q(i, s, s.width, s.height); i.clearRect(s.x - s.width / 2, s.y - s.height / 2, s.width, s.height); i.restore() } } return n }; e.fn.saveCanvas = function lt(e) { var t = this, n, r, i = new C(e), s, o; for (n = 0; n < t.length; n += 1) { r = A(t[n]); if (r) { s = R(t[n]); e = J(t[n], i, e, lt); for (o = 0; o < i.count; o += 1) O(r, s) } } return t }; e.fn.restoreCanvas = function ct(e) { var t = this, n, r, i = new C(e), s, o; for (n = 0; n < t.length; n += 1) { r = A(t[n]); if (r) { s = R(t[n]); e = J(t[n], i, e, ct); for (o = 0; o < i.count; o += 1) M(r, s) } } return t }; e.fn.restoreCanvasOnRedraw = function (t) { var n = this, r = l({}, t); r.layer = s; n.restoreCanvas(r); return n }; e.fn.rotateCanvas = function ht(e) { var t = this, n, r, i = new C(e), s; for (n = 0; n < t.length; n += 1) { r = A(t[n]); if (r) { s = R(t[n]); e = J(t[n], i, e, ht); i.autosave && O(r, s); j(r, i, s.transforms) } } return t }; e.fn.scaleCanvas = function pt(e) { var t = this, n, r, i = new C(e), s; for (n = 0; n < t.length; n += 1) { r = A(t[n]); if (r) { s = R(t[n]); e = J(t[n], i, e, pt); i.autosave && O(r, s); F(r, i, s.transforms) } } return t }; e.fn.translateCanvas = function dt(e) { var t = this, n, r, i = new C(e), s; for (n = 0; n < t.length; n += 1) { r = A(t[n]); if (r) { s = R(t[n]); e = J(t[n], i, e, dt); i.autosave && O(r, s); I(r, i, s.transforms) } } return t }; e.fn.drawRect = function vt(e) { var t = this, n, r, i = new C(e), u, a, f, l, c; for (n = 0; n < t.length; n += 1) { r = A(t[n]); if (r) { e = J(t[n], i, e, vt); if (i.visible) { D(t[n], r, i); q(r, i, i.width, i.height); r.beginPath(); u = i.x - i.width / 2; a = i.y - i.height / 2; c = i.cornerRadius; if (c) { i.closed = s; f = i.x + i.width / 2; l = i.y + i.height / 2; f - u - 2 * c < 0 && (c = (f - u) / 2); l - a - 2 * c < 0 && (c = (l - a) / 2); r.moveTo(u + c, a); r.lineTo(f - c, a); r.arc(f - c, a + c, c, 3 * v / 2, v * 2, o); r.lineTo(f, l - c); r.arc(f - c, l - c, c, 0, v / 2, o); r.lineTo(u + c, l); r.arc(u + c, l - c, c, v / 2, v, o); r.lineTo(u, a + c); r.arc(u + c, a + c, c, v, 3 * v / 2, o) } else r.rect(u, a, i.width, i.height); i._event && it(t[n], r, i); B(t[n], r, i) } } } return t }; e.fn.drawArc = function mt(e) { var t = this, n, r, i = new C(e); e = e || {}; i.layer && !i.inDegrees && i.end === 360 && (e.end = i.end = v * 2); for (n = 0; n < t.length; n += 1) { r = A(t[n]); if (r) { e = J(t[n], i, e, mt); if (i.visible) { D(t[n], r, i); q(r, i, i.radius * 2); r.beginPath(); r.arc(i.x, i.y, i.radius, i.start * i._toRad - v / 2, i.end * i._toRad - v / 2, i.ccw); i._event && it(t[n], r, i); B(t[n], r, i) } } } return t }; e.fn.drawEllipse = function gt(e) { var t = this, n, r, i = new C(e), o = i.width * 4 / 3, u = i.height; i.closed = s; for (n = 0; n < t.length; n += 1) { r = A(t[n]); if (r) { e = J(t[n], i, e, gt); if (i.visible) { D(t[n], r, i); q(r, i, i.width, i.height); r.beginPath(); r.moveTo(i.x, i.y - u / 2); r.bezierCurveTo(i.x - o / 2, i.y - u / 2, i.x - o / 2, i.y + u / 2, i.x, i.y + u / 2); r.bezierCurveTo(i.x + o / 2, i.y + u / 2, i.x + o / 2, i.y - u / 2, i.x, i.y - u / 2); i._event && it(t[n], r, i); B(t[n], r, i) } } } return t }; e.fn.drawPolygon = function yt(e) { var t = this, n, r, i = new C(e), o = 2 * v / i.sides, u = o / 2, a = u + v / 2, f = i.radius * g(u), l, c, h; i.projection && (i.concavity = -i.projection); for (n = 0; n < t.length; n += 1) { r = A(t[n]); if (r) { e = J(t[n], i, e, yt); if (i.visible) { D(t[n], r, i); q(r, i, i.radius * 2); r.beginPath(); for (h = 0; h < i.sides; h += 1) { l = i.x + i.radius * g(a); c = i.y + i.radius * m(a); r.lineTo(l, c); if (i.concavity) { l = i.x + (f + -f * i.concavity) * g(a + u); c = i.y + (f + -f * i.concavity) * m(a + u); r.lineTo(l, c) } a += o } i._event && it(t[n], r, i); i.closed = s; B(t[n], r, i) } } } return t }; e.fn.drawLine = function bt(e) { var t = this, n, r, i = new C(e), o, u, f; for (n = 0; n < t.length; n += 1) { r = A(t[n]); if (r) { e = J(t[n], i, e, bt); if (i.visible) { D(t[n], r, i); q(r, i, 0); o = 1; r.beginPath(); while (s) { u = i["x" + o]; f = i["y" + o]; if (u === a || f === a) break; r.lineTo(u + i.x, f + i.y); o += 1 } i._event && it(t[n], r, i); B(t[n], r, i) } } } return t }; e.fn.drawQuadratic = e.fn.drawQuad = function wt(e) { var t = this, n, r, i = new C(e), o, u, f, l, c; for (n = 0; n < t.length; n += 1) { r = A(t[n]); if (r) { e = J(t[n], i, e, wt); if (i.visible) { D(t[n], r, i); q(r, i, 0); o = 2; r.beginPath(); r.moveTo(i.x1 + i.x, i.y1 + i.y); while (s) { u = i["x" + o]; f = i["y" + o]; l = i["cx" + (o - 1)]; c = i["cy" + (o - 1)]; if (u === a || f === a || l === a || c === a) break; r.quadraticCurveTo(l + i.x, c + i.y, u + i.x, f + i.y); o += 1 } i._event && it(t[n], r, i); B(t[n], r, i) } } } return t }; e.fn.drawBezier = function Et(e) { var t = this, n, r, i = new C(e), o, u, f, l, c, h, p, d; for (n = 0; n < t.length; n += 1) { r = A(t[n]); if (r) { e = J(t[n], i, e, Et); if (i.visible) { D(t[n], r, i); q(r, i, 0); o = 2; u = 1; r.beginPath(); r.moveTo(i.x1 + i.x, i.y1 + i.y); while (s) { f = i["x" + o]; l = i["y" + o]; c = i["cx" + u]; h = i["cy" + u]; p = i["cx" + (u + 1)]; d = i["cy" + (u + 1)]; if (f === a || l === a || c === a || h === a || p === a || d === a) break; r.bezierCurveTo(c + i.x, h + i.y, p + i.x, d + i.y, f + i.x, l + i.y); o += 1; u += 2 } i._event && it(t[n], r, i); B(t[n], r, i) } } } return t }; e.fn.drawVector = function St(e) { var t = this, n, i, o = new C(e), u, f, l, c, h; for (n = 0; n < t.length; n += 1) { i = A(t[n]); if (i) { e = J(t[n], o, e, St); if (o.visible) { D(t[n], i, o); q(i, o, 0); u = 1; i.beginPath(); c = o.x; h = o.y; i.moveTo(o.x, o.y); while (s) { f = o["a" + u]; l = o["l" + u]; if (f === a || l === a) break; f = f * o._toRad - v / 2; c += l * r.cos(f); h += l * r.sin(f); i.lineTo(c, h); u += 1 } o._event && it(t[n], i, o); B(t[n], i, o) } } } return t }; e.fn.drawText = function xt(t) { var n = this, r, i, s, o = new C(t), a, f, l, c; for (i = 0; i < n.length; i += 1) { r = e(n[i]); s = A(n[i]); if (s) { t = J(n[i], o, t, xt); if (o.visible) { D(n[i], s, o); s.textBaseline = o.baseline; s.textAlign = o.align; st(s, o); !i && o.maxWidth !== u ? a = ut(s, o) : i || (a = String(o.text).split("\n")); if (!i) { ot(n[i], s, o, a); if (t && o.layer) { t.width = o.width; t.height = o.height } l = o.x; o.align === "left" ? o.respectAlign ? o.x += o.width / 2 : l -= o.width / 2 : o.align === "right" && (o.respectAlign ? o.x -= o.width / 2 : l += o.width / 2) } q(s, o, o.width, o.height); for (f = 0; f < a.length; f += 1) { s.shadowColor = o.shadowColor; c = o.y + f * o.height / a.length - (a.length - 1) * o.height / a.length / 2; s.fillText(a[f], l, c); o.fillStyle !== "transparent" && (s.shadowColor = "transparent"); s.strokeText(a[f], l, c) } if (o._event) { s.beginPath(); s.rect(o.x - o.width / 2, o.y - o.height / 2, o.width, o.height); it(n[i], s, o); s.closePath() } H(s, o) } } } S = o; return n }; e.fn.measureText = function Tt(e) { var t = this, n, r, i; e === a || h(e) === "object" && !e.layer ? r = new C(e) : r = t.getLayer(e); n = A(t[0]); if (n) { st(n, r); i = ut(n, r); Tt(t[0], n, r, i) } return r }; e.fn.drawImage = function Nt(t) { function v(e, n) { if (e === 0) { c.width === u && c.sWidth === u && (c.width = c.sWidth = h.width); c.height === u && c.sHeight === u && (c.height = c.sHeight = h.height); if (t && c.layer) { t.width = c.width; t.height = c.height } } if (c.sWidth !== u && c.sHeight !== u && c.sx !== u && c.sy !== u) { if (e === 0) { c.width === u && (c.width = c.sWidth); c.height === u && (c.height = c.sHeight); if (!c.cropFromCenter) { c.sx += c.sWidth / 2; c.sy += c.sHeight / 2 } c.sx + c.sWidth / 2 > h.width && (c.sx = h.width - c.sWidth / 2); c.sx - c.sWidth / 2 < 0 && (c.sx = c.sWidth / 2); c.sy - c.sHeight / 2 < 0 && (c.sy = c.sHeight / 2); c.sy + c.sHeight / 2 > h.height && (c.sy = h.height - c.sHeight / 2) } q(n, c, c.width, c.height); n.drawImage(h, c.sx - c.sWidth / 2, c.sy - c.sHeight / 2, c.sWidth, c.sHeight, c.x - c.width / 2, c.y - c.height / 2, c.width, c.height) } else { q(n, c, c.width, c.height); n.drawImage(h, c.x - c.width / 2, c.y - c.height / 2, c.width, c.height) } D(r[e], n, c); n.beginPath(); n.rect(c.x - c.width / 2, c.y - c.height / 2, c.width, c.height); c._event && it(r[e], n, c); l = R(r[e]); n.closePath(); n.stroke(); H(n, c); P(n, l, c) } function m(n, r, i) { return function () { v(r, i); c.load && c.load.call(n, t); c.layer && c._next && e(n).drawLayers({ clear: o, resetFire: s, index: c._next }) } } var r = this, i, a, f, l, c = new C(t), h, p, d; d = c.source; p = d.getContext; if (d.src || p) h = d; else if (d) if (S.source === d) h = S._source; else { h = new n; h.src = d; S.source = d; S._source = h } for (a = 0; a < r.length; a += 1) { i = r[a]; f = A(r[a]); if (f) { t = J(r[a], c, t, Nt); if (c.visible && h) if (h.complete || p) m(i, a, f)(); else { e(h).bind("load", m(i, a, f)); h.src = h.src } } } return r }; e.fn.createPattern = e.fn.pattern = function (r) { function h() { f = s.createPattern(a, o.repeat); o.load && o.load.call(i[0], f) } var i = this, s, o = new C(r), a, f, l, c; s = A(i[0]); if (s) { c = o.source; if (p(c)) { a = e("<canvas />")[0]; a.width = o.width; a.height = o.height; l = A(a); c.call(a, l); h() } else { l = c.getContext; if (c.src || l) a = c; else { a = new n; a.src = c } if (a.complete || l) h(); else { e(a).bind("load", h); a.src = a.src } } } else f = u; return f }; e.fn.createGradient = e.fn.gradient = function (t) { var n = this, r, i = new C(t), s, o = [], f, l, c, h, p, d, v; r = A(n[0]); if (r) { i.x1 = i.x1 || 0; i.y1 = i.y1 || 0; i.x2 = i.x2 || 0; i.y2 = i.y2 || 0; i.r1 !== u || i.r2 !== u ? s = r.createRadialGradient(i.x1, i.y1, i.r1, i.x2, i.y2, i.r2) : s = r.createLinearGradient(i.x1, i.y1, i.x2, i.y2); for (h = 1; i["c" + h] !== a; h += 1) i["s" + h] !== a ? o.push(i["s" + h]) : o.push(u); f = o.length; o[0] === u && (o[0] = 0); o[f - 1] === u && (o[f - 1] = 1); for (h = 0; h < f; h += 1) { if (o[h] !== u) { d = 1; v = 0; l = o[h]; for (p = h + 1; p < f; p += 1) { if (o[p] !== u) { c = o[p]; break } d += 1 } l > c && (o[p] = o[h]) } else if (o[h] === u) { v += 1; o[h] = l + v * ((c - l) / d) } s.addColorStop(o[h], i["c" + (h + 1)]) } } else s = u; return s }; e.fn.setPixels = function Ct(e) { var t = this, n, r, i, s = new C(e), o = {}, a, f, l, c; for (r = 0; r < t.length; r += 1) { n = t[r]; i = A(n); if (i) { e = J(n, s, e, Ct); q(i, s, s.width, s.height); if (s.width === u || s.height === u) { s.width = n.width; s.height = n.height; s.x = s.width / 2; s.y = s.height / 2 } if (s.width !== 0 && s.height !== 0) { a = i.getImageData(s.x - s.width / 2, s.y - s.height / 2, s.width, s.height); f = a.data; c = f.length; o = []; if (s.each) for (l = 0; l < c; l += 4) { o.r = f[l]; o.g = f[l + 1]; o.b = f[l + 2]; o.a = f[l + 3]; s.each.call(n, o); f[l] = o.r; f[l + 1] = o.g; f[l + 2] = o.b; f[l + 3] = o.a } i.putImageData(a, s.x - s.width / 2, s.y - s.height / 2); i.restore() } } } return t }; e.fn.getCanvasImage = function (t, n) { var r = this[0]; n === a && (n = 1); return r && r.toDataURL ? r.toDataURL("image/" + t, n) : u }; e.fn.detectPixelRatio = function (n) { var r = this, i, o, u, a, f, l, c, h, p, d; for (u = 0; u < r.length; u += 1) { o = r[u]; i = e(r[u]); a = A(o); d = R(r[u]); if (!d.scaled) { f = window.devicePixelRatio || 1; l = a.webkitBackingStorePixelRatio || a.mozBackingStorePixelRatio || a.msBackingStorePixelRatio || a.oBackingStorePixelRatio || a.backingStorePixelRatio || 1; c = f / l; if (c !== 1) { h = o.width; p = o.height; o.width = h * c; o.height = p * c; o.style.width = h + "px"; o.style.height = p + "px"; a.scale(c, c) } d.pixelRatio = c; d.scaled = s; n && n.call(o, c) } } return r }; e.support.canvas = e("<canvas />")[0].getContext !== a; k.defaults = f; k._detectEvents = it; k.closePath = B; e.jCanvas = k })(jQuery, document, Image, Math, parseFloat, !0, !1, null);